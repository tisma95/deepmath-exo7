#!/usr/bin/python3

# Descente de gradient
# Application à la régression circulaire

from descente_lot import *


def points_sur_cercle(xc,yc,r,num=5,ecart=0):
    points = []
    for i in range(num):
        theta = 2*np.pi*np.random.random()
        R = r + ecart*(1-2*np.random.random())
        x = xc + R*np.cos(theta)
        y = yc + R*np.sin(theta)
        points.append((x,y))
    return points


def points_sur_cercle_avec_angles(xc,yc,r,angles,ecart=0):
    # angles en degrés
    points = []
    for theta in angles:
        R = r + ecart*(1-2*np.random.random())
        x = xc + R*np.cos(theta*np.pi/180)
        y = yc + R*np.sin(theta*np.pi/180)
        points.append((x,y))
    return points


def affiche_points(points, xc, yc, r):
    theta = np.linspace(0, 2*np.pi, 100)

    x = xc + r*np.cos(theta)
    y = yc + r*np.sin(theta)

    plt.plot(x, y, color='blue')

    for x, y in points:   
        plt.scatter(x, y, color='red')
    
    plt.axis('equal')
    plt.tight_layout()
    # plt.savefig('circulaire-04.png')
    plt.show()
    return


# Test
xc, yc, r = 3, 2, 1
points = points_sur_cercle(xc, yc, r, num = 1000)
# points = [(2.739445552402646, 1.0345408450704723), (2.2859003671849623, 1.299955919664034), (2.248139826461228, 1.340677408663826), (3.9004932350608246, 1.5651299807877177), (2.0130887209916093, 2.1612641540021276), (2.179933302271579, 2.572267954088644), (2.0759965990007956, 2.3823842503842223), (3.0440987457382356, 1.0009728228800208), (3.1491200421458645, 2.9888191002556614), (3.9336908205605075, 1.6419197693239038)]
# points = [(2.0376814980689577, 1.7280751926704832), (3.7838638572569874, 2.6209327284708044), (2.9649976852514035, 1.0006127687616575), (2.6906558725376875, 1.0490498378965485), (3.998098952112559, 1.9383681754950302), (2.714448535184376, 1.0416366237477293), (2.165403968071697, 2.5508624723917315), (3.30369698464529, 1.047231328434148), (2.6762801269873564, 2.9461529706219167), (3.9302967143319334, 2.366807883371131), (3.736411710967474, 2.676533659140443), (3.583820807714501, 1.1881174564756378), (2.05753110890865, 1.6657061332823444), (3.7372058822781473, 2.6756681782757705), (2.485770757114916, 2.8576527769218925), (3.9993809440737804, 2.0351813675430557), (3.9225806950329307, 2.385804174617842), (2.3926764593078187, 1.2055453965637102), (3.747413625058553, 2.6643589941265438), (2.3503040426866075, 2.7601941614157757), (3.2828054375764233, 2.9591772956430984), (2.8682625828254484, 1.008715352224106), (2.0110242111058567, 2.1480773074485313), (2.9619197123674468, 2.999274682804394), (2.343102517234429, 2.753979904994991), (3.0555018672394145, 2.998458583383877), (3.999979622117061, 2.0063839917464934), (2.0012041536241765, 2.0490597315769468), (2.047503806091963, 1.695449510605052), (2.0132799699753114, 1.8375697615956992), (3.9572665567039946, 1.7107929125763375), (3.793278921955951, 2.6088584005993543), (3.905234491835516, 2.4249123613067702), (2.307423355599309, 2.7213442947931865), (3.1691046665488574, 1.0144019015078207), (3.0082479528613546, 1.0000340149417097), (2.2047224637826908, 2.606245528138663), (2.723635993854316, 1.038946964987307), (2.574884636463233, 1.0948608241353144), (2.184391156557524, 1.421396323466203), (2.354632336540448, 1.2361279040567337), (2.292748572081418, 2.7069621048593246), (2.298424794785261, 1.28740458082591), (2.238539278462394, 2.6482110532499643), (2.0007479393201395, 2.0386693577274406), (2.364334080410658, 1.228035727074992), (2.5548118853150803, 2.8954370678854473), (2.1465918803110937, 2.521243303313381), (2.054450098645425, 1.67452283636428), (3.9882022417603875, 2.1531545930742673), (2.011744911827486, 1.8471867783824425), (3.5293719628721716, 2.8483898425398926), (2.158594097258611, 1.4595963482433267), (2.1717957002017925, 1.4395736999428372), (2.245337551702133, 1.3438867558652172), (2.162071357192918, 2.5457797995194413), (3.9952300432161927, 2.09755593820929), (2.8943339251991844, 2.9944016696668347), (2.9294710572347458, 1.0024902665976558), (3.9937570907968616, 1.8884345730481062), (2.0002507515221613, 2.0223928597547727), (3.52126833778046, 1.146607171328704), (3.4939113218362543, 1.1304877193725416), (2.4223459396237557, 1.1837183166756475), (3.73673433415721, 2.676182313340073), (3.2718380054082825, 1.0376569744547184), (3.887617980589912, 1.5394195829895863), (2.507442316711156, 1.1297202009507936), (2.5857646722654763, 1.0898301843849842), (3.993593483596196, 2.1130132264612227), (2.3489762570937622, 2.7590573668520406), (3.3661517338609417, 1.0694448389318203), (3.5274740340936375, 1.1504288473841733), (3.5478514377530184, 2.8365756404246723), (2.023402166106339, 2.2150736404913656), (3.3877093220375674, 2.9217816886905323), (2.864563607679834, 1.0092139566812126), (3.5781067465737, 1.1840388553577006), (3.9710484330815152, 2.2388826921523073), (3.326860767248063, 2.945072504538148), (3.273352466283546, 1.0380860593708485), (2.205389589278149, 2.6071196712119047), (2.7036919841222398, 1.0449075648260084), (3.8464571560954623, 2.5324568366494904), (3.37495051831688, 1.0729551743233219), (2.2337673754001086, 2.642563277038738), (2.866757292234893, 1.0089165621263656), (3.96090243461966, 2.2768871812525995), (3.9125670220935564, 1.5910728302163109), (3.9462001927064354, 2.323581821680861), (2.9202150299517537, 1.0031879020826442), (2.029586125644936, 1.7585524643753978), (2.512845874711419, 1.1266839871991827), (3.634388740580805, 1.2269858178375377), (3.9156955933675177, 1.598127407892365), (2.846509048097562, 2.9881500532227294), (3.9983837002097062, 2.0568329759521307), (2.5545428217442554, 1.1046967539763806), (2.1184613989379604, 2.4721119515936687), (2.6898942748548085, 2.9507020770105505)]

# Test



def exemple_circulaire_1():
    # à trouver (a, b, c) = (xc, yc, r)
    # fonction erreur de 2 variables
    # somme des 
    def E(a, b, c):
        return sum([( (x-a)**2 + (y-b)**2 - c**2 )**2 for x,y in points])
    
    # gradient calculer par nos soins 
    def grad_Ei(a, b, c, xi, yi):
        gia = -2*(xi-a)*((xi-a)**2 + (yi-b)**2 - c**2)
        gib = -2*(yi-b)*((xi-a)**2 + (yi-b)**2 - c**2)
        gic = -2*c*((xi-a)**2 + (yi-b)**2 - c**2)

        return np.array([gia, gib, gic])

    xc, yc, r = 3, 2, 1
    angles = [10, 20, 40, 100, 200, 280]
    points = points_sur_cercle_avec_angles(xc,yc,r,angles)
    affiche_points(points, xc, yc, r)

    # Test
    print("\n --- Descente de gradient ---")
    X0 = np.array([1, 1, 2])
    delta = 0.01
    N = len(points)

    for K in [1, 2, 3, 6]:  
    # for K in [1, 10, 100]:
        liste_X, liste_grad = descente_lot(E, grad_Ei, points, K, X0, delta=delta, epoques=10)
        liste_erreur = [ E(*X) for X in liste_X ]
        n = len(liste_X)
        liste_rang = [i*K/N for i in range(n)] 
        plt.plot(liste_rang,liste_erreur, label="K={}".format(K))

    plt.xlabel('époque')
    plt.ylabel('erreur')
    plt.legend()
    plt.tight_layout()
    # plt.savefig('circulaire-03.png')
    plt.show()
    return

def exemple_circulaire_2():
    # à trouver (a, b, c) = (xc, yc, r)
    # fonction erreur de 2 variables
    # somme des 
    def E(a, b, c):
        return sum([( (x-a)**2 + (y-b)**2 - c**2 )**2 for x,y in points])
    
    # gradient calculer par nos soins 
    def grad_Ei(a, b, c, xi, yi):
        gia = -2*(xi-a)*((xi-a)**2 + (yi-b)**2 - c**2)
        gib = -2*(yi-b)*((xi-a)**2 + (yi-b)**2 - c**2)
        gic = -2*c*((xi-a)**2 + (yi-b)**2 - c**2)

        return np.array([gia, gib, gic])

    xc, yc, r = 1, 2, 3
    points = points_sur_cercle(xc, yc, r, num = 100, ecart=0.5)
    affiche_points(points, xc, yc, r)

    # Test
    print("\n --- Descente de gradient ---")
    X0 = np.array([1, 1, 1])
    delta = 0.001
    N = len(points)

    for K in [1, 10, 20]:
        liste_X, liste_grad = descente_lot(E, grad_Ei, points, K, X0, delta=delta, epoques=2)
        liste_erreur = [ E(*X) for X in liste_X ]
        n = len(liste_X)
        liste_rang = [i*K/N for i in range(n)] 
        plt.plot(liste_rang,liste_erreur, label="K={}".format(K))

    plt.xlabel('époque')
    plt.ylabel('erreur')
    plt.legend()
    plt.tight_layout()
    # plt.savefig('circulaire-05.png')
    plt.show()
    return

# Test
# exemple_circulaire_1()
exemple_circulaire_2()
